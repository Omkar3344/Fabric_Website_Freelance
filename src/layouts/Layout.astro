---
import "../styles/globals.css";
import Navbar from "../components/Navbar.astro";

const {
    title = "Fabric Loom | Premium Fabrics for Every Occasion",
    description = "Discover curated textiles tailored for celebrations, couture, everyday comfort, and bespoke interiors.",
    ogImage = "/assets/og-default.jpg",
    structuredData,
} = Astro.props;
---
<!doctype html>
<html lang="en" class="scroll-smooth bg-[#fefae0] text-slate-900">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta name="description" content={description} />
        <meta name="generator" content={Astro.generator} />
        <title>{title}</title>
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
        <meta property="og:title" content={title} />
        <meta property="og:description" content={description} />
        <meta property="og:type" content="website" />
        <meta property="og:image" content={ogImage} />
        <meta name="theme-color" content="#ccd5ae" />
        {structuredData && (
            <script type="application/ld+json" is:inline>
                {JSON.stringify(structuredData)}
            </script>
        )}
    </head>
    <body class="min-h-screen font-['Inter',sans-serif] text-slate-800 selection:bg-[#ccd5ae] selection:text-slate-900">
        <a href="#main-content" class="sr-only focus:not-sr-only focus:absolute focus:left-4 focus:top-4 focus:rounded-md focus:bg-[#fefae0] focus:px-4 focus:py-2 focus:text-slate-900 focus:shadow">
            Skip to content
        </a>
    <Navbar />
    <main id="main-content" class="flex flex-1 flex-col" data-main-shell>
            <slot />
        </main>
    <footer class="border-t-2 border-[#d4a373]/30 bg-slate-900">
            <div class="mx-auto grid max-w-6xl gap-8 px-4 py-10 md:grid-cols-4 md:px-6">
                <div>
                    <a href="/" class="text-lg font-semibold text-[#d4a373]">Fabric Loom</a>
                    <p class="mt-3 text-sm text-slate-400">
                        Luxury and everyday textiles crafted with precision, sustainability, and a designer's touch.
                    </p>
                </div>
                <div>
                    <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-300">Explore</h3>
                    <ul class="mt-3 space-y-2 text-sm text-slate-400">
                        <li><a href="/#collections" class="transition hover:text-[#d4a373]">Collections</a></li>
                        <li><a href="/products#filters" class="transition hover:text-[#d4a373]">Fabric Categories</a></li>
                        <li><a href="/about#process" class="transition hover:text-[#d4a373]">Craftsmanship</a></li>
                        <li><a href="/contact#showroom" class="transition hover:text-[#d4a373]">Visit us</a></li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-300">Contact</h3>
                    <ul class="mt-3 space-y-2 text-sm text-slate-400">
                        <li>+91 98765 43210</li>
                        <li><a href="mailto:hello@fabricloom.com" class="transition hover:text-[#d4a373]">hello@fabricloom.com</a></li>
                        <li>Mon – Sat, 9:30 AM – 7:30 PM IST</li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-sm font-semibold uppercase tracking-wide text-slate-300">Newsletter</h3>
                    <form class="mt-3 space-y-3">
                        <label class="block text-xs font-medium uppercase tracking-wide text-slate-400">
                            Be the first to view new arrivals
                            <input
                                type="email"
                                required
                                placeholder="Email address"
                                class="mt-2 w-full rounded-md border border-slate-700 bg-slate-800 px-3 py-2 text-sm text-slate-200 placeholder:text-slate-500 focus:border-[#d4a373] focus:outline-none focus:ring-2 focus:ring-[#d4a373]/40"
                            />
                        </label>
                        <button
                            type="submit"
                            class="w-full rounded-full bg-[#d4a373] px-4 py-2 text-sm font-semibold text-[#fefae0] transition hover:bg-[#c68d58]"
                        >
                            Subscribe
                        </button>
                    </form>
                </div>
            </div>
            <div class="border-t border-slate-800 bg-slate-950">
                <div class="mx-auto flex max-w-6xl flex-col items-center justify-between gap-4 px-4 py-4 text-xs text-slate-500 md:flex-row md:px-6">
                    <p>© {new Date().getFullYear()} Fabric Loom Textiles Pvt. Ltd. All rights reserved.</p>
                    <div class="flex gap-4">
                        <a href="#" class="transition hover:text-[#d4a373]">Privacy</a>
                        <a href="#" class="transition hover:text-[#d4a373]">Terms</a>
                        <a href="#" class="transition hover:text-[#d4a373]">Sitemap</a>
                    </div>
                </div>
            </div>
        </footer>
        <script is:inline>
            (() => {
                // Enhanced smooth scrolling for anchor links
                document.addEventListener('DOMContentLoaded', () => {
                    // Smooth scroll for all internal anchor links
                    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                        anchor.addEventListener('click', function (e) {
                            const targetId = this.getAttribute('href');
                            if (targetId && targetId !== '#') {
                                const targetElement = document.querySelector(targetId);
                                if (targetElement) {
                                    e.preventDefault();
                                    targetElement.scrollIntoView({
                                        behavior: 'smooth',
                                        block: 'start',
                                        inline: 'nearest'
                                    });
                                    // Update URL without jump
                                    if (window.history.pushState) {
                                        window.history.pushState(null, null, targetId);
                                    }
                                }
                            }
                        });
                    });

                    // Restore scroll position smoothly
                    if ('scrollRestoration' in history) {
                        history.scrollRestoration = 'manual';
                    }
                });

                const redirectToHomeOnReload = () => {
                    if (typeof window === "undefined") return false;
                    try {
                        const navigationEntry = performance.getEntriesByType?.("navigation")?.[0];
                        const navType = navigationEntry?.type ?? performance?.navigation?.type;
                        const reloadType = performance?.navigation?.TYPE_RELOAD;
                        const isReload = navType === "reload" || (typeof reloadType === "number" && navType === reloadType);

                        if (!isReload) {
                            sessionStorage.removeItem("fabric-home-reload-redirected");
                            return false;
                        }

                        if (window.location.pathname !== "/") {
                            window.location.replace("/");
                            return true;
                        }

                        const homeReloadKey = "fabric-home-reload-redirected";
                        if (!sessionStorage.getItem(homeReloadKey)) {
                            sessionStorage.setItem(homeReloadKey, "1");
                            window.location.replace("/");
                            return true;
                        }

                        sessionStorage.removeItem(homeReloadKey);
                    } catch {
                        // Ignore unsupported performance APIs
                    }
                    return false;
                };

                const ensureHomeLanding = () => {
                    if (typeof window === "undefined") return false;
                    try {
                        const storageKey = "fabric-landing-visited";
                        const isFirstVisit = !sessionStorage.getItem(storageKey);
                        if (isFirstVisit) {
                            sessionStorage.setItem(storageKey, "1");
                            if (window.location.pathname !== "/") {
                                window.location.replace("/");
                                return true;
                            }
                        }
                    } catch {
                        // Ignore storage errors (e.g., private mode restrictions)
                    }
                    return false;
                };

                if (redirectToHomeOnReload() || ensureHomeLanding()) {
                    return;
                }

                /** @type {HTMLElement | null} */
                const siteHeader = document.querySelector('[data-site-header]');
                if (siteHeader) {
                    siteHeader.removeAttribute("data-hidden");
                }

                // Make navbar transparent when hero section is in view with smooth transition
                const heroSection = document.querySelector('#hero');
                if (heroSection && siteHeader) {
                    const observer = new IntersectionObserver(
                        (entries) => {
                            entries.forEach(entry => {
                                // Smooth transition based on intersection ratio
                                requestAnimationFrame(() => {
                                    if (entry.isIntersecting) {
                                        siteHeader.setAttribute('data-over-hero', 'true');
                                    } else {
                                        siteHeader.removeAttribute('data-over-hero');
                                    }
                                });
                            });
                        },
                        { 
                            threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5], 
                            rootMargin: '0px 0px -40% 0px' 
                        }
                    );
                    observer.observe(heroSection);
                }

                const navToggle = document.querySelector("[data-nav-toggle]");
                const mobileMenu = document.querySelector("#mobile-menu");
                const searchToggleButtons = document.querySelectorAll("[data-search-toggle]");
                const searchPanel = document.querySelector("[data-search-panel]");
                const searchClose = document.querySelector("[data-search-close]");
                const searchInput = document.querySelector("[data-search-input]");
                const searchResults = document.querySelector("[data-search-results]");
                const quickLinks = [
                    { title: "Home", description: "Hero, collections, testimonials", href: "/" },
                    { title: "About", description: "Heritage, process, sustainability", href: "/about" },
                    { title: "Products", description: "Browse all fabrics and filter by occasion", href: "/products" },
                    { title: "Contact", description: "Request swatches or book a consultation", href: "/contact" },
                    { title: "Sweater Knits", description: "Soft merino and cashmere blends", href: "/products#category-sweaters" },
                    { title: "Casual Cottons", description: "Handloom cottons for everyday wear", href: "/products#category-casuals" },
                    { title: "Bridal Silks", description: "Heritage brocades and Banarasi weaves", href: "/products#category-traditionals" },
                    { title: "Artisanal Embroidery", description: "Handcrafted embellishments and panels", href: "/products#category-embroidery" },
                    { title: "Seasonal Collections", description: "Limited editions and exclusive collaborations", href: "/#seasonal-highlights" },
                ];

                if (navToggle && mobileMenu) {
                    navToggle.addEventListener("click", () => {
                        const isOpen = mobileMenu.classList.toggle("hidden");
                        navToggle.setAttribute("aria-expanded", (!isOpen).toString());
                    });
                }

                const closeSearchPanel = () => {
                    if (!searchPanel) return;
                    searchPanel.classList.add("invisible");
                    searchPanel.classList.add("opacity-0");
                    searchPanel.setAttribute("aria-hidden", "true");
                };

                const renderSearchResults = (term = "") => {
                    if (!searchResults) return;
                    const normalized = term.trim().toLowerCase();
                    const matches = normalized
                        ? quickLinks.filter(
                              (item) =>
                                  item.title.toLowerCase().includes(normalized) ||
                                  item.description.toLowerCase().includes(normalized)
                          )
                        : quickLinks.slice(0, 6);

                    const list = matches
                        .map(
                            (item) => `
                                <li>
                                    <a href="${item.href}" class="flex flex-col rounded-md border border-transparent px-3 py-2 transition hover:border-[#d4a373] hover:bg-[#fefae0]">
                                        <span class="text-sm font-semibold text-slate-800">${item.title}</span>
                                        <span class="text-xs text-slate-500">${item.description}</span>
                                    </a>
                                </li>
                            `
                        )
                        .join("");

                    searchResults.innerHTML = list || '<li class="px-3 py-2 text-xs text-slate-500">No matches yet. Try another phrase.</li>';
                };

                const openSearchPanel = () => {
                    if (!searchPanel) return;
                    searchPanel.classList.remove("invisible");
                    searchPanel.classList.remove("opacity-0");
                    searchPanel.classList.add("opacity-100");
                    searchPanel.setAttribute("aria-hidden", "false");
                    requestAnimationFrame(() => searchInput?.focus());
                    renderSearchResults("");
                };

                searchToggleButtons.forEach((btn) => btn.addEventListener("click", openSearchPanel));
                searchClose?.addEventListener("click", closeSearchPanel);
                searchInput?.addEventListener("input", (event) => renderSearchResults(event.target.value));

                document.addEventListener("keydown", (event) => {
                    if (event.key === "Escape") {
                        closeSearchPanel();
                    }
                });

                document.addEventListener("click", (event) => {
                    if (!(event.target instanceof Element)) {
                        return;
                    }
                    if (searchPanel && !searchPanel.contains(event.target) && !event.target.closest("[data-search-toggle]")) {
                        closeSearchPanel();
                    }
                });

                // ========================================
                // MOBILE SCROLL CONTROL SYSTEM - ENHANCED
                // ========================================
                
                // Check if device is mobile (touch-enabled with small screen)
                const isMobileDevice = () => {
                    return (
                        ('ontouchstart' in window || navigator.maxTouchPoints > 0) &&
                        window.matchMedia('(max-width: 47.99rem)').matches &&
                        window.matchMedia('(hover: none)').matches
                    );
                };

                if (isMobileDevice()) {
                    const sections = Array.from(document.querySelectorAll('.section-block'));
                    let currentSectionIndex = 0;
                    let isTransitioning = false;
                    let scrollLocked = false;
                    let navLinkClicked = false;
                    let lastTouchY = 0;
                    let isTouching = false;
                    
                    const SCROLL_THRESHOLD = 0.9; // 90% scroll required
                    const DEBOUNCE_TIME = 100; // ms to wait before checking scroll
                    
                    // Check if section content is scrolled to bottom
                    const isScrolledToBottom = (element) => {
                        if (!element) return false;
                        const scrollTop = element.scrollTop;
                        const scrollHeight = element.scrollHeight;
                        const clientHeight = element.clientHeight;
                        
                        // If content fits within viewport (no scroll needed)
                        if (scrollHeight <= clientHeight + 10) {
                            return true;
                        }
                        
                        // Check if scrolled to 90% or more
                        const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
                        return scrollPercentage >= SCROLL_THRESHOLD;
                    };
                    
                    // Check if section content is at the top
                    const isScrolledToTop = (element) => {
                        if (!element) return false;
                        return element.scrollTop <= 5;
                    };
                    
                    // Get current section based on which section is most visible
                    const getCurrentSection = () => {
                        let maxVisibility = 0;
                        let mostVisibleIndex = 0;
                        
                        sections.forEach((section, index) => {
                            const rect = section.getBoundingClientRect();
                            const headerHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--header-height')) || 56;
                            
                            // Calculate how much of the section is visible
                            const visibleTop = Math.max(rect.top, headerHeight);
                            const visibleBottom = Math.min(rect.bottom, window.innerHeight);
                            const visibleHeight = Math.max(0, visibleBottom - visibleTop);
                            
                            if (visibleHeight > maxVisibility) {
                                maxVisibility = visibleHeight;
                                mostVisibleIndex = index;
                            }
                        });
                        
                        return mostVisibleIndex;
                    };
                    
                    // Snap to a specific section
                    const snapToSection = (index, instant = false) => {
                        if (index < 0 || index >= sections.length || isTransitioning) return;
                        
                        isTransitioning = true;
                        scrollLocked = true;
                        
                        const targetSection = sections[index];
                        
                        // Scroll the section into view
                        targetSection.scrollIntoView({
                            behavior: instant ? 'auto' : 'smooth',
                            block: 'start',
                            inline: 'nearest'
                        });
                        
                        // Reset the section's internal scroll to top
                        setTimeout(() => {
                            if (!navLinkClicked) {
                                targetSection.scrollTop = 0;
                            }
                        }, instant ? 0 : 300);
                        
                        // Update state after transition
                        setTimeout(() => {
                            currentSectionIndex = index;
                            isTransitioning = false;
                            scrollLocked = false;
                        }, instant ? 100 : 600);
                    };
                    
                    // Prevent body scroll, only allow section scroll
                    let lastScrollTop = window.scrollY;
                    let scrollDirection = 'down';
                    
                    window.addEventListener('scroll', () => {
                        const currentScrollTop = window.scrollY;
                        scrollDirection = currentScrollTop > lastScrollTop ? 'down' : 'up';
                        lastScrollTop = currentScrollTop;
                    }, { passive: true });
                    
                    // Touch event handlers
                    let touchStartTimestamp = 0;
                    let preventNextScroll = false;
                    
                    document.addEventListener('touchstart', (e) => {
                        if (navLinkClicked || isTransitioning) return;
                        
                        isTouching = true;
                        lastTouchY = e.touches[0].clientY;
                        touchStartTimestamp = Date.now();
                    }, { passive: true });
                    
                    let lastTouchMoveY = 0;
                    document.addEventListener('touchmove', (e) => {
                        if (navLinkClicked || isTransitioning || !isTouching) return;
                        
                        const currentY = e.touches[0].clientY;
                        const deltaY = lastTouchY - currentY;
                        lastTouchMoveY = currentY;
                        
                        const currentSection = sections[currentSectionIndex];
                        if (!currentSection) return;
                        
                        const movingDown = deltaY > 0;
                        const movingUp = deltaY < 0;
                        
                        // Check if we should prevent scrolling to next/previous section
                        if (movingDown && isScrolledToBottom(currentSection)) {
                            // At bottom, trying to scroll down - prepare for next section
                            preventNextScroll = false;
                        } else if (movingUp && isScrolledToTop(currentSection)) {
                            // At top, trying to scroll up - prepare for previous section
                            preventNextScroll = false;
                        } else if (movingDown && !isScrolledToBottom(currentSection)) {
                            // Not at bottom yet, prevent section change
                            preventNextScroll = true;
                        } else if (movingUp && !isScrolledToTop(currentSection)) {
                            // Not at top yet, prevent section change
                            preventNextScroll = true;
                        }
                        
                        lastTouchY = currentY;
                    }, { passive: true });
                    
                    document.addEventListener('touchend', (e) => {
                        if (navLinkClicked || isTransitioning || !isTouching) {
                            isTouching = false;
                            return;
                        }
                        
                        isTouching = false;
                        
                        const touchDuration = Date.now() - touchStartTimestamp;
                        const touchDistance = lastTouchY - lastTouchMoveY;
                        const isSwipe = Math.abs(touchDistance) > 50 || (Math.abs(touchDistance) > 20 && touchDuration < 300);
                        
                        const currentSection = sections[currentSectionIndex];
                        if (!currentSection) return;
                        
                        const swipingDown = touchDistance < 0;
                        const swipingUp = touchDistance > 0;
                        
                        // Handle swipe down (go to next section)
                        if (swipingDown && isSwipe) {
                            const atBottom = isScrolledToBottom(currentSection);
                            
                            if (atBottom && currentSectionIndex < sections.length - 1 && !preventNextScroll) {
                                snapToSection(currentSectionIndex + 1);
                            }
                        }
                        // Handle swipe up (go to previous section)
                        else if (swipingUp && isSwipe) {
                            const atTop = isScrolledToTop(currentSection);
                            
                            if (atTop && currentSectionIndex > 0 && !preventNextScroll) {
                                snapToSection(currentSectionIndex - 1);
                            }
                        }
                        
                        preventNextScroll = false;
                    }, { passive: true });
                    
                    // Wheel event for devices that support it
                    let wheelDebounce = null;
                    let lastWheelTime = 0;
                    
                    document.addEventListener('wheel', (e) => {
                        if (navLinkClicked || isTransitioning) return;
                        
                        const now = Date.now();
                        if (now - lastWheelTime < 100) return;
                        
                        clearTimeout(wheelDebounce);
                        wheelDebounce = setTimeout(() => {
                            const currentSection = sections[currentSectionIndex];
                            if (!currentSection) return;
                            
                            const wheelDown = e.deltaY > 0;
                            const wheelUp = e.deltaY < 0;
                            
                            if (wheelDown) {
                                const atBottom = isScrolledToBottom(currentSection);
                                if (atBottom && currentSectionIndex < sections.length - 1) {
                                    lastWheelTime = now;
                                    snapToSection(currentSectionIndex + 1);
                                }
                            } else if (wheelUp) {
                                const atTop = isScrolledToTop(currentSection);
                                if (atTop && currentSectionIndex > 0) {
                                    lastWheelTime = now;
                                    snapToSection(currentSectionIndex - 1);
                                }
                            }
                        }, DEBOUNCE_TIME);
                    }, { passive: true });
                    
                    // Track section changes from external sources (navbar, etc)
                    let updateSectionDebounce = null;
                    const observeSections = new IntersectionObserver(
                        (entries) => {
                            if (isTransitioning || navLinkClicked) return;
                            
                            clearTimeout(updateSectionDebounce);
                            updateSectionDebounce = setTimeout(() => {
                                currentSectionIndex = getCurrentSection();
                            }, 200);
                        },
                        { threshold: [0.5], rootMargin: '-20% 0px -20% 0px' }
                    );
                    
                    sections.forEach(section => observeSections.observe(section));
                    
                    // Handle navbar link clicks
                    document.addEventListener('click', (e) => {
                        const target = e.target;
                        if (target instanceof HTMLAnchorElement) {
                            const href = target.getAttribute('href');
                            if (href?.startsWith('#')) {
                                navLinkClicked = true;
                                isTransitioning = true;
                                
                                // Allow the default behavior
                                setTimeout(() => {
                                    currentSectionIndex = getCurrentSection();
                                    navLinkClicked = false;
                                    isTransitioning = false;
                                }, 1000);
                            }
                        }
                    });
                    
                    // Initialize
                    setTimeout(() => {
                        currentSectionIndex = getCurrentSection();
                    }, 500);
                }
                
                // ========================================
                // END MOBILE SCROLL CONTROL
                // ========================================

                const animatedElements = Array.from(document.querySelectorAll("[data-animate]"));
                if ("IntersectionObserver" in window && animatedElements.length) {
                    // Enhanced intersection observer with smoother triggering
                    const observer = new IntersectionObserver(
                        (entries, obs) => {
                            for (const entry of entries) {
                                if (entry.isIntersecting) {
                                    // Double requestAnimationFrame for smoother animation start
                                    requestAnimationFrame(() => {
                                        requestAnimationFrame(() => {
                                            entry.target.setAttribute("data-animated", "true");
                                        });
                                    });
                                    obs.unobserve(entry.target);
                                }
                            }
                        },
                        { 
                            threshold: 0.15, 
                            rootMargin: "0px 0px -10%",
                            // Smooth animation triggering
                            delay: 100
                        }
                    );

                    animatedElements.forEach((element, index) => {
                        // Staggered delays for cascading effect
                        const delay = Math.min(index * 100, 400);
                        element.style.setProperty("--animate-delay", `${delay}ms`);
                        observer.observe(element);
                    });
                } else {
                    animatedElements.forEach((element) => {
                        element.setAttribute("data-animated", "true");
                    });
                }
            })();
        </script>
    </body>
</html>

<style>
	html,
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}
</style>
